---
layout: article
title: "BOJ 11438 LCA 2"
date:   2020-02-18 08:31:12 +0900
tags: [boj, 트리, LCA, 스파스 테이블, DP]
---

### 기본 아이디어
LCA 기본 문제다. 스파스 테이블을 활용하는 DP의 대표적인 예시인 것 같다. 스파스 테이블의 아이디어를 거의 그대로 가져와서, 트리의 모든 정점들에 대해 parent[E][i] = E의 2^i번째 조상으로 스파스 테이블을 전처리한 후 두 정점을 스파스 테이블에 따라 올리며 공통 조상을 찾으면 된다. 말은 쉬운데 구현하려면 머리가 아프다.

### 구현
우선 그래프이므로 인접 리스트를 만든다. 이제 루트를 기점으로 DFS를 통해 트리를 만들 수 있다. 여기서 부모 관계는 높이가 1 차이나고 간선 하나로 바로 이어진 직계 부모 관계이므로 parent[i][0]을 사용해줄 수 있다.

트리를 만들 때 각 정점들의 깊이도 기록해줘야 한다. 높이가 다르면 공통 조상을 찾을 때 비교하기가 어려워서, 높이를 우선 맞춰준 후 조상을 찾기 시작해야 하기 때문이다.

트리를 만든 후에는 바로 스파스 테이블 전처리를 해 주고, 이제 쿼리를 받고 처리하면 된다. 우선 더 깊은 정점을 위로 끌어올려 두 정점의 높이를 맞춰 주고, 혹시 이 과정에서 두 정점이 같아졌다면 바로 답이 나왔으므로 다음 과정을 생략한다.

높이를 맞춘 후에는 두 정점을 함께 올려가며 부모를 찾는데, 이 때 반드시 두 정점이 LCA의 직계 자손까지만 오도록 (즉 같아지지 않도록) 처리해 주고, N번 이동한 정점이 존재하지 않는 경우도 처리해 준다. ~~여기서 그냥 직계 자손에서 끊지 말고 그냥 정점 둘을 LCA에서 만나게 해주고 break를 하면 어떨까?? 라는 생각도 든다.~~ 해보니 당연히 안 된다. 조금 더 정밀하게 내려가면 더 가까운 공통 조상이 있을 수 있기 때문이다.

구현하며 헷갈렸던 점은 parent[v1][j] != 0 부분에서 두 번째 정점이 유효한지는 체크하지 않았던 점인데, 사실 정점이 유효하지 않은 경우는 루트보다 높이 올라갔다는 뜻이므로 하나만 체크해줘도 된다.

순수하게 내 손으로 작성한 코드도 아니고 거의 다른 코드들 이것저것 많이 보면서 짠 코드인데도 구현할 때 이렇게 헷갈리는 점들이 많았다...

### 코드
~~~c
#include<bits/stdc++.h>
using namespace std;
int n, m, v1, v2, depth[100001], parent[100001][18];
vector<int> adj[100001];
void dfs(int V) {
    for(auto i:adj[V]) {
        if(depth[i] == 0) {
            parent[i][0] = V;
            depth[i] = depth[V] + 1;
            dfs(i);
        }
    }
}
int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    
    cin >> n;
    for (int i = 0; i<n-1; i++) {
        cin >> v1 >> v2;
        adj[v1].push_back(v2);
        adj[v2].push_back(v1);
    }

    depth[1] = 1;
    dfs(1);

    for(int j = 0; j < 17; j++)
        for(int i = 1; i<=n; i++)
            if(parent[i][j] != 0)
                parent[i][j+1] = parent[parent[i][j]][j];

    cin >> m;
    while(m--) {
        cin >> v1 >> v2;
        if (depth[v1] < depth[v2])
            swap(v1, v2);
        int diff = depth[v1] - depth[v2];
        //높이의 차이만큼 이동시키고 싶다.
        //따라서, diff의 모든 비트를 조사하여 스파스 테이블에 따라 위로 이동한다.
        for(int j = 0; diff != 0; j++) {
            if(diff%2 == 1)
                v1 = parent[v1][j];
            diff /= 2;
        }
        //만약 높이 조정 과정에서 v1 == v2가 되었다면 답은 당연히 v1
        if(v1 != v2) {
            for(int j = 17; j>=0; j--) {
                //스파스에 따라 빠르게 같이 위로 이동한다.
                //위로 이동하다 보면 언젠간 부모 정점이 같은 때가 오게 된다.
                if(parent[v1][j] != parent[v2][j] && parent[v1][j] != 0) {
                    v1 = parent[v1][j];
                    v2 = parent[v2][j];
                }
            }
            v1 = parent[v1][0];
        }
        cout << v1 << '\n';
    }
}
~~~

